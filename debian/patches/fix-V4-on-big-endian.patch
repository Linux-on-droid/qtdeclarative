Description: Fix V4 on big-endian
 We can't both invert offset position and inter-value positions of tag
 and value.
 .
 This patch changes 32-bit big-endian to use the same order inside
 the tag/value but just at different offsets. This also make it
 compatible with how we use it with doubles.
 .
 This fixes value/tag reads on 32-bit big-endian and offsets on 64-bit.
Origin: upstream, https://code.qt.io/cgit/qt/qtdeclarative.git/commit/?id=2a65834439772945
Last-Update: 2016-10-05

--- a/src/qml/jsruntime/qv4value_p.h
+++ b/src/qml/jsruntime/qv4value_p.h
@@ -102,19 +102,16 @@
     Q_ALWAYS_INLINE quint64 rawValue() const { return _val; }
     Q_ALWAYS_INLINE void setRawValue(quint64 raw) { _val = raw; }
 
-#if Q_BYTE_ORDER == Q_LITTLE_ENDIAN || defined(QV4_USE_64_BIT_VALUE_ENCODING)
+#if Q_BYTE_ORDER == Q_LITTLE_ENDIAN
     static inline int valueOffset() { return 0; }
     static inline int tagOffset() { return 4; }
-    Q_ALWAYS_INLINE void setTagValue(quint32 tag, quint32 value) { _val = quint64(tag) << 32 | value; }
-    Q_ALWAYS_INLINE quint32 value() const { return _val & quint64(~quint32(0)); }
-    Q_ALWAYS_INLINE quint32 tag() const { return _val >> 32; }
-#else // !Q_LITTLE_ENDIAN && !defined(QV4_USE_64_BIT_VALUE_ENCODING)
+#else // !Q_LITTLE_ENDIAN
     static inline int valueOffset() { return 4; }
     static inline int tagOffset() { return 0; }
-    Q_ALWAYS_INLINE void setTagValue(quint32 tag, quint32 value) { _val = quint64(value) << 32 | tag; }
-    Q_ALWAYS_INLINE quint32 tag() const { return _val & quint64(~quint32(0)); }
-    Q_ALWAYS_INLINE quint32 value() const { return _val >> 32; }
 #endif
+    Q_ALWAYS_INLINE void setTagValue(quint32 tag, quint32 value) { _val = quint64(tag) << 32 | value; }
+    Q_ALWAYS_INLINE quint32 value() const { return _val & quint64(~quint32(0)); }
+    Q_ALWAYS_INLINE quint32 tag() const { return _val >> 32; }
 
 #if defined(V4_BOOTSTRAP)
     Q_ALWAYS_INLINE Heap::Base *m() const { Q_UNREACHABLE(); return Q_NULLPTR; }
